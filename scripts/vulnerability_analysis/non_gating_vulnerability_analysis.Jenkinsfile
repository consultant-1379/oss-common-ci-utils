#!/usr/bin/env groovy

pipeline {
    agent {
        label env.NODE_LABEL
    }

    options {
        timestamps()
        timeout(time: 120, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '15', artifactNumToKeepStr: '15'))
    }

    environment {
        CREDENTIALS_SELI_ARTIFACTORY = credentials('SELI_ARTIFACTORY')
    }

    stages {
        stage('Prepare') {
            steps {
                script {
                    sh "git submodule add ../../../adp-cicd/bob"
                    if (params.BUILD_TYPE == "--Select--") {
                        nightlyBuild()
                    } else {
                        parameterizedBuild()
                    }
                    htmlReport()
                }
            }
        }
    }
}

// nightly run
def nightlyBuild() {
    // To get the project lists
    sh '''#!/bin/bash
        mkdir -p ${WORKSPACE}/project_lists
        git clone ${GERRIT_MIRROR}/OSS/com.ericsson.oss.ci/oss-common-ci-utils
        cd oss-common-ci-utils
        git checkout dVersion-2.0.0-hybrid
        cp dsl/projects_list_with_jobs_hybrid ${WORKSPACE}/project_lists
        cp dsl/project_list_with_go_microservices ${WORKSPACE}/project_lists
        cd ..
        [ -d oss-common-ci-utils ] && rm -rf oss-common-ci-utils
        rm -f ${WORKSPACE}/pr_list_names.txt || true
        touch ${WORKSPACE}/pr_list_names.txt
        cd ${WORKSPACE}/project_lists && ls | tee ${WORKSPACE}/pr_list_names.txt
    '''

    // Iterating through each project in the project list
    String[] project_lists = (new File("${WORKSPACE}/pr_list_names.txt").text).split('\n')
    for (String project_list in project_lists) {
        def data = readFile(file: "project_lists/${project_list}")
        data.split('\n').each { project_details ->
            env.GERRIT_REPO = project_details.tokenize(',')[0]
            env.FEM_INSTANCE = project_details.tokenize(',')[1]
            for (elem in project_details.tokenize(',')) {
                if (elem.contains("EMAIL=")) {
                    env.EMAIL=elem.tokenize('=')[-1]
                }
            }
            if (env.FEM_INSTANCE != "fem3s11") {
                repoClone()
                if (env.TAGFAIL != "true") {
                    init()
                    if (env.INITFAIL != "true") {
                        imageCheck()
                        vulnerabilityAnalysis()
                        if (env.VAFAIL != "true") {
                            reportUpload()
                            postCleanup()
                        } else {
                            env.VAFAIL ="false"
                            postCleanup()
                        }
                    } else {
                        env.INITFAIL = "false"
                        postCleanup()
                    }
                } else {
                    env.TAGFAIL = "false"
                    postCleanup()
                }
            }
        }
    }
}

// parameterized run
def parameterizedBuild() {
    repoClone()
    init()
    if (env.INITFAIL != "true") {
        imageCheck()
        vulnerabilityAnalysis()
        if (env.VAFAIL != "true") {
            reportUpload()
        } else {
            env.VAFAIL ="false"
        }
    } else {
        env.INITFAIL = "false"
    }
}

def repoClone() {
    env.GERRIT_REPO = env.GERRIT_REPO.replaceAll("\\s","")
    env.ARTIFACT_ID = env.GERRIT_REPO.split("/").last()

    if (params.BUILD_TYPE == "--Select--") {
        // cloning repo from master and getting the latest tag version
        try {
            sh "git clone ${GERRIT_MIRROR}/${GERRIT_REPO}"
            sh "mkdir .bob"
            sh '''#!/bin/bash
                cd ${ARTIFACT_ID}
                git describe --abbrev=0 >> ../.bob/var.version
            '''
            sh "sed -i -e 's/+/-/g;s/v//' .bob/var.version"
        } catch(e) {
            sh "echo '${GERRIT_REPO},Docker image not published yet in the Artifactory,Run the publish job to deploy the Docker image' >> Failed_repos.txt"
            env.TAGFAIL = "true"
            println "ERROR: ----------Docker image not published yet in the Artifactory----------"
        }
    } else {
        env.DOCKER_IMAGE_VERSION = env.DOCKER_IMAGE_VERSION.replaceAll(",","")
        currentBuild.displayName = currentBuild.displayName + ' / ' + "${env.ARTIFACT_ID} / ${env.DOCKER_IMAGE_VERSION}"
        sh '''#!/bin/bash
            mkdir .bob
            echo ${DOCKER_IMAGE_VERSION} >> .bob/var.version
        '''

        if (params.BUILD_TYPE == "SCAN_PUBLISH_IMAGE") {
            // cloning repo using tag version
            sh "git clone --depth 1 --branch ${DOCKER_IMAGE_VERSION} ${GERRIT_MIRROR}/${GERRIT_REPO}"
        } else {
            // cloning repo using patchset
            sh '''#!/bin/bash
                git clone ${GERRIT_MIRROR}/${GERRIT_REPO}
                GERRIT_REFSPEC=$(echo ${GERRIT_REFSPEC} | sed 's/,//')
                cd ${ARTIFACT_ID}
                git pull ${GERRIT_MIRROR}/${GERRIT_REPO} ${GERRIT_REFSPEC}
            '''
        }
    }
}

// copying required config files
def init() {
    try {
        sh "mkdir config"
        sh "cp ${WORKSPACE}/${ARTIFACT_ID}/common-properties.yaml ${WORKSPACE}"
        sh "cp ${WORKSPACE}/${ARTIFACT_ID}/config/va-report.config ${WORKSPACE}/config"
        sh "cp ${WORKSPACE}/${ARTIFACT_ID}/config/hadolint_config.yaml ${WORKSPACE}/config"
        sh "cp ${WORKSPACE}/${ARTIFACT_ID}/config/kubesec_config.yaml ${WORKSPACE}/config"
        sh "cp ${WORKSPACE}/${ARTIFACT_ID}/config/kubeaudit_config.yaml ${WORKSPACE}/config"
        sh "cp ${WORKSPACE}/scripts/vulnerability_analysis/xray_report.config ${WORKSPACE}/config"
        sh "cp ${WORKSPACE}/scripts/vulnerability_analysis/va_html_config.yaml ${WORKSPACE}/config"
        sh "cp -r ${WORKSPACE}/${ARTIFACT_ID}/charts ${WORKSPACE}"
        sh "cp ${WORKSPACE}/${ARTIFACT_ID}/Dockerfile ${WORKSPACE}"
        sh "cp -r ${WORKSPACE}/${ARTIFACT_ID}/ci/local_pipeline_env.txt ${WORKSPACE}/ci"

        env.VERSION = readFile '.bob/var.version'
        env.VERSION = env.VERSION.replaceAll("\\s","")
        setEnvironmentVariables()
    } catch(e) {
        sh "echo '${GERRIT_REPO},Configuration files are not present/naming convention not correct,Check if the required configuration files are there present with correct naming convention' >> Failed_repos.txt"
        env.INITFAIL = "true"
        println "ERROR: ----------Configuration files are not present/naming convention not correct----------"
    }
}

// configuring environment variables
def setEnvironmentVariables() {
    if ((env.SKIP_SCAN == 'No')&&(fileExists(file: 'ci/local_pipeline_env.txt'))) {
        echo "File ci/local_pipeline_env.txt EXISTS"
        def envVariableMap = readProperties  file: 'ci/local_pipeline_env.txt'
        echo "local_pipeline_env: \n$envVariableMap"

        def String[] replaceableVars = ['HADOLINT_ENABLED', 'KUBEAUDIT_ENABLED', 'KUBESEC_ENABLED', 'TRIVY_ENABLED', 'XRAY_ENABLED', 'ANCHORE_ENABLED']
        envVariableMap.each { entry ->
            if (replaceableVars.contains("$entry.key")) {
                env["$entry.key"] = "$entry.value".replaceAll('"', '')
            }
        }
    } else {
        println "----------SKIP_SCAN is enabled. Parameter values are used----------"
    }
}

// checking if the image present in ci-internal repo or not
def imageCheck() {
    def properties = readFile("common-properties.yaml").trim()
    for (data in properties.split("\n")) {
        if (data.contains("docker-image-name")) {
            env.DOCKER_IMAGE_NAME = data.split(":")[1].trim()
        }
    }

    sh '''#!/bin/bash
        response=$(curl -u ${CREDENTIALS_SELI_ARTIFACTORY_USR}:${CREDENTIALS_SELI_ARTIFACTORY_PSW} --write-out '%{http_code}' --silent --output /dev/null https://arm.seli.gic.ericsson.se/artifactory/proj-eric-oss-ci-internal-docker-global/proj-eric-oss-ci-internal/${DOCKER_IMAGE_NAME}/${VERSION})
        if [ ${response} == "200" ] || [ ${response} == "302" ]
        then
            echo "----------Image present in ci-internal repository----------"
        else
            echo "----------Image not present in ci-internal repository----------"
            docker pull armdocker.rnd.ericsson.se/proj-eric-oss-drop/${DOCKER_IMAGE_NAME}:${VERSION}
            docker tag armdocker.rnd.ericsson.se/proj-eric-oss-drop/${DOCKER_IMAGE_NAME}:${VERSION} armdocker.rnd.ericsson.se/proj-eric-oss-ci-internal/${DOCKER_IMAGE_NAME}:${VERSION}
            docker push armdocker.rnd.ericsson.se/proj-eric-oss-ci-internal/${DOCKER_IMAGE_NAME}:${VERSION}
            echo "----------Image pushed to ci-internal repository----------"
            sleep 90
        fi
    '''
}

// executing VA scans
def vulnerabilityAnalysis() {
    try {
        def ruleset = "scripts/vulnerability_analysis/non_gating_vulnerability_analysis_ruleset.yaml"
        def bob = "python3 bob/bob.py -r ${ruleset}"

        stage(env.ARTIFACT_ID+'-'+env.VERSION+'-Vulnerability Analysis') {
            parallel(
                "Trivy": {
                    script {
                        if (env.TRIVY_ENABLED == "true") {
                            sh "${bob} trivy-inline-scan"
                        } else {
                            echo "----------stage Trivy skipped----------"
                        }
                    }
                },
                "Xray": {
                    script {
                        if (env.XRAY_ENABLED == "true") {
                            withCredentials([usernamePassword(credentialsId: 'SELI_ARTIFACTORY', usernameVariable: 'SELI_ARTIFACTORY_REPO_USER', passwordVariable: 'SELI_ARTIFACTORY_REPO_PASS')]) {
                                sh "${bob} fetch-xray-report"
                            }
                        } else {
                            echo "----------stage Xray skipped----------"
                        }
                    }
                },
                "Anchore-Grype": {
                    script {
                        if (env.ANCHORE_ENABLED == "true") {
                            sh "${bob} anchore-grype-scan"
                        } else {
                            echo "----------stage Anchore skipped----------"
                        }
                    }
                },
                "Hadolint": {
                    script {
                        if (env.HADOLINT_ENABLED == "true") {
                            sh "${bob} hadolint-scan"
                            echo "Evaluating Hadolint Scan Resultcodes..."
                            sh "${bob} evaluate-design-rule-check-resultcodes"
                        } else {
                            echo "----------stage Hadolint skipped----------"
                        }
                    }
                },
                "Kubeaudit": {
                    script {
                        if (env.KUBEAUDIT_ENABLED == "true") {
                            sh "${bob} kube-audit"
                        } else {
                            echo "----------stage Kubeaudit skipped----------"
                        }
                    }
                },
                "Kubesec": {
                    script {
                        if (env.KUBESEC_ENABLED == "true") {
                            sleep(20)
                            sh "${bob} kubesec-scan"
                        } else {
                            echo "----------stage Kubsec skipped----------"
                        }
                    }
                }
            )
        }

        stage(env.ARTIFACT_ID+'-'+env.VERSION+'-Vulnerability Report') {
            script {
                sh "${bob} generate-VA-report-V2"

                archiveArtifacts allowEmptyArchive: true, artifacts: 'build/va-reports/Vulnerability_Report_2.0.md'
                archiveArtifacts allowEmptyArchive: true, artifacts: 'build/html/html-va-report/Vulnerability_Report_2.0.html'
            }
        }
    } catch(e) {
        sh "echo '${GERRIT_REPO},VA analysis failed,Check if the failure is due to config files or infra' >> Failed_repos.txt"
        env.VAFAIL= "true"
        println "ERROR: ----------Failed in VA analysis----------"
    }
}

// uploading .md and .html report
def reportUpload() {
    try {
        sh '''#!/bin/bash
            cd ${WORKSPACE}/build/html/html-va-report/
            curl -u ${CREDENTIALS_SELI_ARTIFACTORY_USR}:${CREDENTIALS_SELI_ARTIFACTORY_PSW} -X PUT -T  Vulnerability_Report_2.0.html  https://arm.seli.gic.ericsson.se/artifactory/proj-eric-oss-ci-internal-build-artifacts-generic-local/${JOB_NAME}/${BUILD_NUMBER}/${ARTIFACT_ID}/${VERSION}-Vulnerability_Report_2.0.html
            cd ${WORKSPACE}/build/va-reports/
            curl -u ${CREDENTIALS_SELI_ARTIFACTORY_USR}:${CREDENTIALS_SELI_ARTIFACTORY_PSW} -X PUT -T  Vulnerability_Report_2.0.md  https://arm.seli.gic.ericsson.se/artifactory/proj-eric-oss-ci-internal-build-artifacts-generic-local/${JOB_NAME}/${BUILD_NUMBER}/${ARTIFACT_ID}/${VERSION}-Vulnerability_Report_2.0.md
        '''
        sendMail()
    } catch(e) {
        sh "echo '${GERRIT_REPO},The HTML report not generated,Check if the Vulnerability_Report_2.0.md file is generated or not' >> Failed_repos.txt"
        println "ERROR: ----------The HTML report not generated----------"
    }
}

// cleaning-up the files
def postCleanup() {
    sh '''#!/bin/bash
        rm -rf .bob config Dockerfile charts build common-properties.yaml ${ARTIFACT_ID} ci/local_pipeline_env.txt
    '''
}

// to send mail
def sendMail() {
    mail to: "${env.EMAIL}",
        from: 'jenkins-ossadmin-no-reply@ericsson.com',
        subject: "Vulnerability report for ${env.ARTIFACT_ID}-${env.VERSION}",
        body: " <br> Hello, <br> We wanted to inform you that the build artifacts for the Jenkins build <a href='${env.BUILD_URL}'>${env.BUILD_DISPLAY_NAME}</a> have been uploaded to https://arm.seli.gic.ericsson.se/artifactory/proj-eric-oss-ci-internal-build-artifacts-generic-local/${env.JOB_NAME}/${env.BUILD_NUMBER}/${env.ARTIFACT_ID} <br><br>" +
        "Please note that artifacts that are older than 10 days will be deleted automatically from the artifactory. If you require access to the artifacts that are older than 10 days, please download them now.<br><br>" +
        "Best Regards,<br>" +
        "The Hummingbirds<br>",
        mimeType: 'text/html'
}

// generating failed_repos.html file
def htmlReport() {
    def file = new File("${WORKSPACE}/Failed_repos.txt")
    if (file.exists()){
        def html_report = new File("${WORKSPACE}/Failed_repos.html")
        def header = "<html>\n<head>\n<style> table, th, td { border: 1px solid rgb(255, 255, 255); border-collapse: collapse; font-size:14px;} th { background: #000; color: #eee; font-weight: bold; padding: 5px; text-align:left;} td { background: #aaa; font-weight: normal; overflow: hidden; padding: 5px; text-overflow: ellipsis; white-space: nowrap; } body { background: #e1e2e3; font-family: sans-serif; font-size:14px;}\n</style>\n</head>\n<body>\n<b>Failed Repositories list</b>"
        def date = String.format('%tF %<tH:%<tM', java.time.LocalDateTime.now())
        html_report.append("${header}")
        html_report.append("\n<p><b>Report generated</b>: ${date}</p>\n")
        html_report.append("<br><table>\n")
        html_report.append("<tr>\n")
        html_report.append("<th>Repositories</th>\n")
        html_report.append("<th>Reason for the failure</th>\n")
        html_report.append("<th>Solution</th>\n")
        html_report.append("</tr>\n")

        String[] input_data = new File("${WORKSPACE}/Failed_repos.txt").text.split('\n')
        for (String data in input_data) {
            html_report.append("<tr>\n")
            for (String elem in data.split(",")) {
                html_report.append("<td>${elem}</td>\n")
            }
            html_report.append("</tr>\n")
        }

        html_report.append("<br></table>\n")
        html_report.append("<br><body>\n")
        html_report.append("<br></html>\n")
        archiveArtifacts allowEmptyArchive: true, artifacts: 'Failed_repos.txt'
        archiveArtifacts allowEmptyArchive: true, artifacts: 'Failed_repos.html'
    }
}
